# APPS
Apps - сервис, позволяющий пользователям использовать инфраструктуру Timeweb.Cloud для автоматического развёртывания проектов, расположенных на сервисах хостинга IT-проектов (GitHub, GitLab, Bitbucket, etc).
IT-проекты могут быть трёх видов:

**Frontend**

Проект на языке программирования Javascript с использованием фреймворков Angular, Ember, Next.js, Nuxt, Preact, React, Svelte, Vue, etc.
В развёрнутом состоянии представляет собой облачный сервер с запущенным nginx и артефактами проекта. Nginx выполняет функцию веб-сервера.
На одном облачном сервере может быть любое количество Frontend-приложений.

**Backend**

Проект на языках программирования Python, PHP, Java, Go, Elixir, .NET, Node.JS с использованием фреймворков FastAPI, Flask, Django, Celery, Yii, Symfony, Laravel, Nest, Hapi, Fastify, Express, Spring, Gin, Beego, Phoenix и ASP.NET.
В развёрнутом состоянии представляет собой отдельный облачный сервер с запущенным Docker контейнером, внутри которого запущено пользовательское приложение.
Nginx используется как прокси-сервер

**Docker**

Проект на любом языке программирования, для которого написан Dockerfile. В развёрнутом состоянии аналогичен Backend-приложению.


# Структура проекта
Backend-составляющая проекта Apps состоит из пяти элементов:
* Apps API
* RabbitMQ
* Apps Agent
* Log API
* TTYD Manager

## Apps API
### Описание
Сервис, представляющий собой асинхронный REST API интерфейс. Написан на Python с использованием фреймворков FastAPI и SQLAlchemy.
Использует MySQL для хранения данных.
### Задачи
* Ведёт базу данных, содержащую информацию о существующих приложениях
* Выполняет балансировку запросов между VDS на установку Frontend-приложений
* Управляет параметрами подключения к консоли приложений
* Проксирует запросы на получение логов на конкретную VDS
* Хранит информацию о доступных языках и фреймворках
### Расположение
Внутренний кластер kubernetes
### Сущности
Сервис оперирует сущностями VDS, App и Deploy
#### VDS
Сущность, хранящая в себе информацию об облачном сервере, где будет развёрнуто пользовательское приложение.
Является моделью таблицы vds из MySQL базы данных apps.
Содержит в себе следующую информацию:
* id - уникальный идентификатор облачного сервера
* ip - IPv4 адрес сервера
* token - уникальный токен, использующийся для доступа к сервису Log API на облачном сервере
* apps - список приложений, установленных на облачном сервере
* region - зона установки облачного сервера
* type - тип пользовательского приложения. 
* disk_total - размер жёсткого диска
* disk_free - размер свободного места на жёстком диске
* cpu - количество ядер процессора
* la - показатель load average, отображающий среднее количество активных процессов на CPU
```python
class VDS(SQLModel, table=True):
    id: int = Field(
        primary_key=True,
        index=True,
        nullable=False
    )
    ip: str
    token: str | None
    apps: list['App'] = Relationship(back_populates='vds')
    region: Region | None
    type: AppType | None
    disk_total: int | None = Field(sa_column=Column(BigInteger()))
    disk_free: int | None = Field(sa_column=Column(BigInteger()))
    memory_total: int | None = Field(sa_column=Column(BigInteger()))
    memory_free: int | None = Field(sa_column=Column(BigInteger()))
    cpu: int | None
    la: float | None
```
 
#### App
Сущность, описывающая клиентское приложение. Является моделью таблицы app из MySQL базы данных apps.
Содержит в себе следующую информацию:
* id - уникальный идентификатор приложения
* created_at - дата создания приложения
* name - название приложения (заполняется пользователем)
* description - описание приложения (заполняется пользователем)
* status - текущий статус приложения. Может принимать одно из значений NEW, DEPLOY, ACTIVE, FAILED, STARTUP_ERROR, PAUSED, REBOOT
* type - тип приложения: Frontend, Backend или Docker.
* build_cmd - команда сборки приложения
* run_cmd - команда запуска приложения
* env_version - версия языка, на котором написано приложение
* language - язык, на котором написано приложение
* framework - используемый фреймворк
* vds_id - идентификатор VDS, на которой развёрнуто приложение
* domains - список доменных имён приложения с параметрами защищённого соединения (https)
* ports - порты приложения
* envs - пользовательские переменные окружения
* index_dir - полный путь директории, где находится index.html. Используется для Frontend-приложений
* repository - общая информация о репозитории пользователя - используемая ветка и коммит, с которого взят код приложения
* console_creds - информация о параметрах подключения к консоли приложения
```python 
class App(SQLModel, table=True):
    id: str = Field(
        default_factory=tools.get_uuid,
        primary_key=True,
        index=True,
        nullable=False,
    )
    created_at: datetime = Field(default_factory=datetime.utcnow)
    name: str = Field(sa_column_kwargs={'name': 'app_name'})
    description: str
    status: AppStatus = Field(AppStatus.NEW, sa_column_kwargs={'name': 'app_status'})
    type: AppType = Field(sa_column_kwargs={'name': 'app_type'})
    build_cmd: str | None
    run_cmd: str | None
    env_version: str | None
    branch: str | None
    language: str | None = Field(default=None, foreign_key='app_language.language_name',
                                 sa_column_kwargs={'name': 'app_language'})
    framework: str | None = Field(default=None, foreign_key='app_framework.framework_name',
                                  sa_column_kwargs={'name': 'app_framework'})
    vds_id: int | None = Field(default=None, foreign_key='vds.id')
    vds: VDS | None = Relationship(back_populates='apps',
                                   sa_relationship_kwargs={'lazy': 'selectin'})
    domains: list[dict] | None = Field(default=[], sa_column=Column(JSON))
    ports: dict | None = Field(default={}, sa_column=Column(JSON))
    envs: dict = Field(default={}, sa_column=Column(JSON))
    index_dir: str = Field(default=None)
    repository: dict = Field(default={}, sa_column=Column(JSON))
    persistent_dir: str

    console_creds: ConsoleCreds = Relationship(back_populates='app',
                                               sa_relationship_kwargs={'lazy': 'selectin',
                                                                       'uselist': False,
                                                                       "cascade": "delete"})
```

#### Deploy
Сущность процесса развёртывания приложения на инфраструктуре Timeweb.Cloud
Является моделью таблицы deploy из MySQL базы данных apps.
Содержит в себе следующую информацию:
* id - уникальный идентификатор развёртывания
* app_id - идентификатор развёртываемого приложения
* is_auto - булево значение, отображающее тип развёртывания - автоматический или ручной.
* created_at - дата создания задачи на развёртывание приложения
* ended_at - дата выполнения задачи на развёртывание приложения
* commit - идентификатор коммита
* clone_url - ссылка на скачивание кода с репозитория
* status - статус развёртывания
```python
class Deploy(SQLModel, table=True):
    id: str = Field(
        default_factory=tools.get_uuid,
        primary_key=True,
        index=True,
        nullable=False,
    )
    app_id: str
    is_auto: bool
    created_at: datetime = Field(default_factory=datetime.utcnow)
    ended_at: datetime | None
    commit: str | None = Field(sa_column_kwargs={'name': 'commit_sha'})
    clone_url: str | None
    status: DeployStatus = Field(DeployStatus.CREATED,
                                 sa_column_kwargs={'name': 'deploy_status'})
```
### Интерфейсы взаимодействия
**GET /api/v1/app** 

Получение списка всех приложений. Код ответа - 200. Необязательные параметры:
* limit - максимальное количество возвращаемых значений
* offset - сдвиг SQL запроса
* repository_id - идентификатор репозитория, по которому необходимо осуществить поиск
___
**POST /api/v1/app**

Создание пользовательского приложения. Пример передаваемых данных в формате JSON:
```json
{
  "name": "Моё приложение!",
  "description": "Оно точно будет работать",
  "type": "backend",
  "build_cmd": "dotnet build",
  "run_cmd": "dotnet run",
  "env_version": "8.0",
  "language": "dotnet",
  "framework": "ASP.NET Core",
  "vds": {
    "id": 123456,
    "ip": "192.168.100.100"
  },
  "domains": [
    {
      "name": "mysite.example",
      "ssl": true
    }
  ],
  "envs": {"TEST_ENV": 1984},
  "protection_user": "console_user",
  "protection_password": "megapassword",
  "is_autodeploy": true,
  "repository": {
        "clone_url": "https://gitlab.com/my/project.git",
        "branch": "main",
        "commit": "34e261f17e81d930fee6ba825f121e7d69744c86"
      }
}
```
___
**POST /app/{app_id}/{action}**

Управление состоянием приложения. Обязательные параметры:
* app_id - уникальный идентификатор приложения
* action - выполняемое действие. Возможные варианты:
  * reboot - перезагрузка приложения (только Backend и Docker, рестарт пользовательского docker-контейнера)
  * pause - временная приостановка работы приложения
  * resume - восстановление работы приложения после остановки
___
**GET /app/{app_id}**

Получение информации о приложении по его идентификатору. Обязательные параметры:
* app_id - уникальный идентификатор приложения
___
**DELETE /app/{app_id}**

Удаление приложения. Обязательные параметры:
* app_id - уникальный идентификатор приложения
___
**GET /console/{app_id}**
Получение уникального токена доступа к консоли приложения (только Backend и Docker приложения). Обязательные параметры:
* app_id - уникальный идентификатор приложения
___
**PUT /console/{app_id}**

Создание или обновления уникального токена доступа к консоли приложения (только Backend и Docker приложения). Обязательные параметры:
* app_id - уникальный идентификатор приложения
___
**GET /deploy**

Получение списка всех развёртываний пользовательского приложения. Обязательные параметры:
* app_id - уникальный идентификатор приложения

Необязательные параметры:
* limit - максимальное количество возвращаемых значений
* offset - сдвиг SQL запроса
___
**POST /deploy**
Запуск нового развёртывания уже существующего приложения. Пример JSON-запроса:
```json
{
  "is_auto": true,
  "app_id": "486ac80f-e3be-4bef-a4fc-37c9896d2e21",
  "commit": "34e261f17e81d930fee6ba825f121e7d69744c86",
  "clone_url": "https://gitlab.com/my/project.git"
}
```
___
**POST /deploy/{deploy_id}/{action}**
Управление состоянием развёртывания. Обязательные параметры:
* deploy_id - уникальный идентификатор развёртывания
* action - выполняемое действие. Возможные варианты:
  * stop - остановка активного развёртывания
___
**GET /log/app/{app_id}**
Получение логов пользовательского приложения (только Backend и Docker приложения)
Обязательные параметры:
* app_id - уникальный идентификатор приложения
___
**GET /log/app/{app_id}/deploy/{deploy_id}**
Получение логов развёртывания. Обязательные параметры:
* app_id - уникальный идентификатор приложения
* deploy_id - уникальный идентификатор развёртывания

Необязательные параметры:
* debug - принимает булевы значения true/false. При true отдаёт дополнительные логи с пометкой DEBUG. Стандартное значение false.
___
**GET /vds**
Получение списка активных облачных серверов для услуги Apps. Необязательные параметры:
* limit - максимальное количество возвращаемых значений
* offset - сдвиг SQL запроса
* type - тип приложения (Frontend/Backend/Deploy). Стандартное значение - frontend
___
**POST /vds**
Создание облачного сервера в базе данных Apps API. Используется для подготовки новых серверов для Frontend-приложений. Пример JSON-запроса:
```json
{
  "id": 2,
  "ip": "192.168.100.101",
  "type": "frontend"
}
```
___
**GET /vds/{region}**
Получение наиболее свободного облачного сервера в данной локации. Обязательные параметры:
* region - локация в инфраструктуре Timeweb.Cloud
___
**GET /vds/one/{ip_or_id}**
Получение информации об облачном сервере. Обязательные параметры:
* ip_or_id - уникальный идентификатор или IPv4 адрес облачного сервера
___
**GET /language**
Получение списка доступных языков программирования и их версий, которые поддерживаются услугой Apps.
___
**GET /language/framework**
Получение списка доступных фреймворков, которые поддерживаются услугой Apps.


## RabbitMQ
### Описание
RabbitMQ — программный брокер сообщений на основе стандарта AMQP — тиражируемое связующее программное обеспечение, ориентированное на обработку сообщений. 
Состоит из сервера, библиотек поддержки протоколов HTTP, XMPP и STOMP, клиентских библиотек AMQP для Java и .NET Framework и различных плагинов (таких как плагины для мониторинга и управления через HTTP или веб-интерфейс или плагин «Shovel» для передачи сообщений между брокерами). Имеется реализация клиентов для доступа к RabbitMQ для целого ряда языков программирования, в том числе для Perl, Python, Ruby, PHP. Поддерживается горизонтальное масштабирование для построения кластерных решений. 
### Задачи
* Обмен сообщениями между Apps API и всеми активными Apps Agent

RabbitMQ установлен на облачном сервере в инфраструктуре Timeweb.Cloud и имеет доступ в интернет.
Для установления адресата сообщения используется белый (внешний) IP-адрес облачного сервера, на котором установлен Apps Agent.
Каждый адресат имеет собственную очередь сообщений, идентифицируемую по названию, содержащему IP-адрес адресата.

## Apps Agent
### Описание
Сервис, отвечающий за установку, конфигурирование и использование пользовательского приложения на облачном сервере. Написан на Python, реализован как systemd-unit.
### Задачи
* Взаимодействие с Docker API для создания образов и запуска контейнеров
* Настройка nginx
* Выпуск и поддержание актуальности SSL-сертификатов
* Сбор и отправка метрик о текущем состоянии облачного сервера в Apps API
* Настройка и запуск консоли клиентского приложения
* Ведение и сбор логов
### Расположение
Устанавливается на каждый облачный сервер, выделенный под клиентское приложение
### Процесс установки
В качестве базового дистрибутива используется официальный образ Ubuntu 22.04 LTS. В образ дополнительно копируются файлы Apps Agent, после чего данный образ используется как эталонный.
Для каждого нового Backend или Docker-приложения устанавливается новый облачный сервер с использованием подготовленного образа.
При запуске сервера выполняются команды cloud-init, запускающие обновление Apps Agent с использованием Bash-скрипта agent-update.sh
### Запуск
Apps Agent запускается автоматически вместе с запуском облачного сервера, так как интегрирован в systemd через написанный unit:
```unit file (systemd)
[Unit]
Description=Apps Agent Worker
After=network.target

[Service]
ExecStart=/root/agent-light/worker.py
WorkingDirectory=/root/agent-light/
User=root
Group=root
Restart=always

[Install]
WantedBy=multi-user.target
```

## Log API
Асинхронный REST API интерфейс на облачном сервере, отвечающий за передачу пользовательских логов в Apps API. Написан на Python с использованием FastAPI

### Задачи
* Парсинг логов работы Apps Agent
* Сбор логов пользовательского приложения (Только Backend и Docker)
* Отправка логов в Apps API

### Расположение
Устанавливается на каждый облачный сервер, выделенный под клиентское приложение

### Процесс установки
Устанавливается на облачный сервер вместе с Apps Agent

### Запуск
```я тут хочу указать systemd, потому что планирую в будущем апишку туда перенести```

### Сущности
Apps Agent оперирует следующими сущностями:
* **Worker** - точка входа приложения, работает с очередью rabbit, парсит получаемые от Apps API задания и запускает их выполнение в отдельных потоках
* **DeployManager** - сущность, отвечающая за верхнеуровневое взаимодействие с пользовательским приложением (установка/изменение параметров). Является родительским классом для сущностей FrontendDeploy, BackendDeploy и DockerDeploy.
  * FrontendDeploy - сущность взаимодействия с пользовательским Frontend приложением.
  * BackendDeploy - сущность взаимодействия с пользовательским Backend приложением.
  * DockerDeploy - сущность взаимодействия с пользовательским Docker приложением. Наследуется от BackendDeploy.
* **ImageManager** - верхнеуровневая сущность создания docker-образов. Использует DockerInterface.
* **DockerInterface** - сущность взаимодействия с низкоуровневым API Docker. Через неё выполняется сборка docker-образов и запуск контейнеров.
* **NginxManager** - сущность генерации конфигурации nginx. Использует готовые txt шаблоны и jinja2 в качестве шаблонизатора. Является родительским классом для сущностей Frontend и Backend.
  * Frontend - сущность работы с шаблонами, конфигурирующих nginx как веб-сервер.
  * Backend - сущность работы с шаблонами, конфигурирующих nginx как proxy-сервер. Используется как для Backend, так и для Docker приложений.
* **SSLManager** - сущность работы с SSL-сертификатами. Может использовать wildcard-сертификаты для технических доменов, либо выпускать новые сертификаты для пользовательских доменов, используя запуск certbot в отдельном docker-контейнере через DockerInterface
* **PortsManager** (Только Backend и Docker) - верхнеуровневая сущность работы с портами пользовательского приложения. Определяет порты, на которых запущено пользовательское приложение в docker-контейнере и генерирует публичный порт для проксирования через nginx.
* **CommandsFabric** - фабрика команд, выполняющихся при установке пользовательского приложения. Использует yaml-шаблон для записи стандартных команд установки компонентов и jinja2 в качестве шаблонизатора.

## TTYD Manager
Python-скрипт, отвечающий за запуск консоли пользовательского приложения. Использует утилиту ttyd.

### Принцип работы
Принцип работы заключается в многопоточном запуске ttyd для каждого запущенного приложения на облачном сервере. 
Apps Agent при установке приложения генерирует конфигурацию nginx, содержащую параметры прокси-сервера на инстанс ttyd.
Пример конфигурации:
```
  server {
    listen       80;
    server_name {{ip}};

    location /{{unique_string}} {
        {{console_proxy}}
        deny all;
        rewrite ^/([^/]+)(/?.*)$ /$2 break;
        proxy_pass http://127.0.0.1:{{console_port}};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
      }
    }
```
### Расположение
Устанавливается на каждый облачный сервер, выделенный под клиентское приложение

### Процесс установки
Устанавливается на облачный сервер вместе с Apps Agent


## Пример работы проекта APPS

Развёртывание пользовательского приложения с нуля на инфраструктуре Timeweb.Cloud состоит из следующих шагов:

---
**ДОДЕЛАТЬ**

Здесь надо дописать, как собирается информация у клиента с панели, как создаётся вдс и как генерируется json

---
1. **Обработка запроса в Apps API**
   1. Apps API получает запрос на эндпоинт **POST /app**
   2. Происходит запись полученных данных в базу MySQL
   3. Генерируются параметры консоли пользовательского приложения (только Backend и Docker приложения). Параметры консоли представляют собой url-ссылку, на которой будет доступна консоль, и уникальный токен доступа.
   4. Создаётся объект сущности Deploy, данные о нём записываются в базу MySQL
   5. Генерируется JSON, содержащий параметры развёртывания
   6. Задача отправляется в RabbitMQ в очередь для облачного сервера, указанного в параметрах приложения
2. **Обработка задачи в Apps Agent**
   1. Worker получает задачу и парсит JSON в Pydantic-модель
   2. Отправка модели в DeployManager, получение объекта развёртывания в зависимости от типа приложения:
    ```python
    class DeployManager:
        @staticmethod
        def get_env_object(params: ds.DeployParameters):
            match params.environment:
                case ds.EnvironmentName.JS:
                    return FrontendDeploy(params)
                case ds.EnvironmentName.DOCKER:
                    return DockerDeploy(params)
                case _:
                    return BackendDeploy(params)
    ```
    3. Создаётся объект класса ImageManager и происходит поэтапное создание docker-образов с использованием методов сущности DockerInterface (self.docker). 
       ```python
        def create_final_image(self):
            self.status_updater.update(
                app_status=ds.AppStatus.DEPLOY,
                deploy_status=ds.DeployStatus.PREPARING_ENVIRONMENT
            )
            match self.params.environment:
                case ds.EnvironmentName.DOCKER:
                    result_image, volumes = self.docker.create_image_from_clone()
                    self.check_image(result_image, 'final')
                case _:
                    env_image = self.prepare_environment()
                    with self.docker.block_docker_prune:
                        self.status_updater.update(
                            app_status=ds.AppStatus.DEPLOY,
                            deploy_status=ds.DeployStatus.CLONING_CODE
                        )
                        code_image = self.clone_code(env_image)
                        self.status_updater.update(
                            app_status=ds.AppStatus.DEPLOY,
                            deploy_status=ds.DeployStatus.INSTALLING_DEPENDENCIES
                        )
                        dependencies_image = self.install_dependencies(code_image)
                        self.status_updater.update(
                            app_status=ds.AppStatus.DEPLOY,
                            deploy_status=ds.DeployStatus.BUILDING_CODE
                        )
                        result_image = self.build_code(dependencies_image)
                        volumes = {}
            return result_image, volumes
       ```
       В процессе сборки приложения потребуется пять наследуемых образов:
       * **Базовый образ.** Используется официальный docker-образ Ubuntu 22.04 LTS.
       * **Образ языка.** Здесь происходит установка языка программирования в систему. Вызывается CommandsFabric для получения команд установки необходимого языка. Пример команд установки языка Elixir:
       ```yaml
       elixir:
         setup:
          - add-apt-repository ppa:rabbitmq/rabbitmq-erlang
          - DEBIAN_FRONTEND=noninteractive apt-get -y update
          - DEBIAN_FRONTEND=noninteractive apt install -y elixir erlang-dev erlang-xmerl inotify-tools --fix-missing
       ```
       * **Образ кода.** На данном этапе в образ клонируется код из пользовательского репозитория.
       * **Образ зависимостей.** В данном образе устанавливаются все необходимые зависимости для пользовательского приложения. Зависимости могут быть как указаны пользователем в специальном файле в репозитории (Пример для Python - requirements.txt), либо будут установлены минимальные зависимости, необходимые для указанного пользователем фреймворка. Для получения образца файла зависимостей или команд установки стандартных зависимостей происходит обращение к сущности CommandsFabric.
       * **Образ сборки.** В данном образе пользовательское приложение собирается, если это необходимо (Пример для компилируемой группы языков .NET - dotnet build), и прокидываются переменные окружения, указанные пользователем при создании приложения.
       ```
       Зачем разделять приложение на пять отдельных образов?
       Это сделано для оптимизации последующих деплоев. Если клиент вносит коммит, ему нужно пересобрать приложение,
        мы пересобираем только последние три образа. Образ языка и базовый образ нам трогать не надо,
        что экономит кучу времени. Точно так же, если клиент хочет добавить новые переменные окружения,
        нам достаточно пересобрать финальный образ.
       
       TODO - переписать, скопировал из букстака
       ```
   4. Создание объекта окружения сущности NginxManager через вызов метода get_env_object:
   ```python
   class NginxManager:
        @staticmethod
        def get_env_object(params: DeployParameters,
                           image: str,
                           build_dir: str,
                           log: Logger = None):
            match params.environment:
                case EnvironmentName.JS:
                    return Frontend(
                        params=params,
                        image=image,
                        build_dir=build_dir,
                        log=log
                    )
                case _:
                    return Backend(
                        params=params,
                        image=image,
                        build_dir=build_dir,
                        log=log
                    )
   ```
   Далее принцип работы отличается для каждого из типов приложений.
#### Frontend
1. Из финального образа (образа сборки) на облачный сервер в отдельную директорию копируются конечные артефакты, получившиеся в процессе сборки приложения. Путь к папке с артефактами уникален для каждого фреймворка и получается из CommandsFabric.
2. Создаётся объект класса SSLManager и вызывается метод выпуска SSL сертификата.
    * В случае, если приложение будет запускаться на техническом домене (*.twc1.ru), то на облачный сервер копируется существующий wildcard-сертификат в директорию /etc/letsencrypt/sites-enabled/<app_id>.
    * Если у клиента собственный домен, то с использованием DockerInterface создаётся отдельный docker-контейнер, в котором установлена утилита для получения сертификатов Let's Encrypt certbot.
    * Полученный от certbot сертификат копируется из контейнера в директорию /etc/letsencrypt/sites-enabled/<app_id>
3. Вызывается метод объекта Frontend create_config, генерирующий nginx-конфигурацию в формате файла. Jinja2 позволяет нам использовать готовые шаблоны, меняя только IP-адреса, домены и прочие параметры, характерные для конкретного приложения. Для frontend-приложений характерны такие параметры, как page_404, try_files_404, root_headers, etc. Nginx конфигурируется как веб-сервер.
4. Полученный конфигурационный файл nginx сохраняется на сервере в директорию /etc/nginx/sites-enabled/<domain>
5. Выполняем reload сервиса nginx, чтобы nginx перечитал файлы конфигурации.
6. Удаляем все созданные во время развёртывания docker-образы, кроме образа языка.
7. Приложение развёрнуто!
#### Backend
1. Определяются порты пользовательского приложения.
   * С использованием сущности DockerInterface происходит запуск приложения из образа сборки. В качестве команды запуска используется либо команда, указанная пользователем при создании приложения, либо стандартная команда для указанного языка и фреймворка из CommandsFabric. 
   * В контейнер устанавливается утилита lsof, позволяющая определить используемые порты у запущенных процессов.
   * Парсится вывод команды `lsof -i -P -n`
   * Полученные порты сохраняются в атрибуты класса BackendDeploy
   * Временный контейнер останавливается и удаляется
2. Запускается финальный контейнер
   * В команду запуска из пункта 1 добавляется проброс портов пользовательского приложения, развёрнутого в docker-контейнере
3. Создаётся объект класса SSLManager и вызывается метод выпуска SSL сертификата.
   * В случае, если приложение будет запускаться на техническом домене (*.twc1.ru), то на облачный сервер копируется существующий wildcard-сертификат в директорию /etc/letsencrypt/sites-enabled/<app_id>.
   * Если у клиента собственный домен, то с использованием DockerInterface создаётся отдельный docker-контейнер, в котором установлена утилита для получения сертификатов Let's Encrypt certbot.
   * С использованием объекта сущности Backend генерируется временный конфигурационный файл nginx, в котором пробрасываются порты до docker-контейнера с certbot
   * Полученный от certbot сертификат копируется из контейнера в директорию /etc/letsencrypt/sites-enabled/<app_id>
4. Вызывается метод объекта Backend create_config, генерирующий nginx-конфигурацию в формате файла. Jinja2 позволяет нам использовать готовые шаблоны, меняя только IP-адреса, домены и прочие параметры, характерные для конкретного приложения. Nginx конфигурируется как прокси-сервер. 
5. Полученный конфигурационный файл nginx сохраняется на сервере в директорию /etc/nginx/sites-enabled/<domain>
6. Выполняем reload сервиса nginx, чтобы nginx перечитал файлы конфигурации.
7. Приложение развёрнуто!
#### Docker
1. Собирается docker-образ из пользовательского Dockerfile. 
2. Определяются порты пользовательского приложения.
   * С использованием сущности DockerInterface из атрибута образа `ExposedPorts` получаем информацию об используемых портах в пользовательском приложении
   * Полученные порты сохраняются в атрибуты класса DockerDeploy
3. Создаётся объект класса SSLManager и вызывается метод выпуска SSL сертификата.
   * В случае, если приложение будет запускаться на техническом домене (*.twc1.ru), то на облачный сервер копируется существующий wildcard-сертификат в директорию /etc/letsencrypt/sites-enabled/<app_id>.
   * Если у клиента собственный домен, то с использованием DockerInterface создаётся отдельный docker-контейнер, в котором установлена утилита для получения сертификатов Let's Encrypt certbot.
   * С использованием объекта сущности Backend генерируется временный конфигурационный файл nginx, в котором пробрасываются порты до docker-контейнера с certbot
   * Полученный от certbot сертификат копируется из контейнера в директорию /etc/letsencrypt/sites-enabled/<app_id>
4. Вызывается метод объекта Backend (Docker-приложение использует объект класса Backend) create_config, генерирующий nginx-конфигурацию в формате файла. Jinja2 позволяет нам использовать готовые шаблоны, меняя только IP-адреса, домены и прочие параметры, характерные для конкретного приложения. Nginx конфигурируется как прокси-сервер. 
5. Полученный конфигурационный файл nginx сохраняется на сервере в директорию /etc/nginx/sites-enabled/<domain>
6. Выполняем reload сервиса nginx, чтобы nginx перечитал файлы конфигурации.
7. Отправляем в Apps API информацию об обнаруженных портах пользовательского приложения
8. Приложение развёрнуто!

